# EmotiChat 用户需求详细说明

> **创建日期**: 2025-11-23  
> **来源**: 用户原始需求  
> **状态**: 待实现

---

## 🎯 核心设计原则

> **所有功能均用独立单元模块实现，保证项目的高度解耦。不可以都耦合在一起，那样维护和debug太灾难了。**

---

## 📋 当前问题

1. ❌ **角色设定的提示词无法发送给AI**
2. ❌ **当前的可细分自定义内容过少**（指只有聊天、角色、设置）
3. ❌ **UI更像网页端LLM的交互体验**，需要改正，给人一种正经客户端的感觉
   - 💡 原因：用户因为酒馆（SillyTavern）过于重型和陈旧才构建这个项目

---

## 🔧 详细更改需求

### 1. 角色编辑页面改造

#### 1.1 移除内容

- ❌ 系统提示词
- ❌ 背景故事
- ❌ 高级配置

#### 1.2 保留但不发送给LLM

- ✅ **角色名称** - 仅用于UI显示
- ✅ **角色描述** - 仅用于用户备注

#### 1.3 新增内容

**A. 新的提示词机制**
- 只有新的提示词部分发送给AI
- 提示词机制见下文详细说明

**B. 开场白编辑窗口**
- 开场白 = AI的第一条消息
- 位置：第0层楼（关于"楼层"概念见下文）

---

### 2. 高度可定制化

项目需要做到**高度可定制化**，支持用户自由配置各种功能和样式。

---

### 3. 渲染系统

#### 3.1 支持的格式

- ✅ **HTML渲染**
- ✅ **Markdown渲染**
- ✅ **代码块渲染**
  - 支持代码高亮
  - 需要高亮开关

#### 3.2 特殊字段渲染

用户可自定义以下内容的渲染方式：

| 字段类型 | 示例 | 渲染效果 |
|---------|------|---------|
| 引号包裹 | "这是内容" | 特殊背景色/高亮 |
| 括号包裹 | (这是内容) | 特殊背景色/高亮 |
| 其他自定义 | 用户可自由添加 | 自定义样式 |

#### 3.3 CSS完全自定义工具

- 需要一个对**对话界面CSS完全自定义的工具**
- 添加到设置页面
- 让用户可以完全控制对话界面的视觉样式

---

### 4. 统一提示词编辑器

**设计原则**: 全局都使用统一的提示词编辑器

#### 4.1 核心功能

**A. 排序功能**
- 在当前提示词序列中进行先后顺序更改
- 支持拖拽排序

**B. 注入功能**
- 见下文"注入机制"详细说明

**C. 开关功能**
- 决定是否把这部分提示词发送给AI
- 每条提示词独立控制

**D. Role设定功能**
- 设定role为：`role`、`model`或`system`
- **这取决于AI模型**，因为目前适配的三家API协议都有不同
- 开放三个统一的通用设置
- 这个设置要传递给负责提示词后处理部分的模块

---

### 5. 提示词后处理系统（极其重要）

这是**项目最核心、最重要的部分**。

#### 5.1 主要功能

**A. 排序功能**
- 根据上下文对提示词进行智能排序
- 整合所有提示词部分

**B. Role更改**
- ⚠️ **根据用户选择的API类型，自动适配其对role的后处理模式**
- ⚠️ **绝对不可以透传！** 这个问题非常大

**特殊处理 - Gemini系列模型**:
- 强制把所有`system` role提示词合并
- 更改为`System instructions`
- 通过请求体发送给模型

**C. 变量/宏/占位符替代**

见下文详细说明。

#### 5.2 变量系统（实时获取）

通过浏览器权限实时获取信息：

| 变量 | 格式 | 说明 |
|------|------|------|
| `{{time}}` | 年月日时分 | 不精确到秒 |
| `{{location}}` | 省市 | 例：广东省 深圳市 |
| `{{device_info}}` | 设备类型 | 电脑/手机 |

#### 5.3 占位符系统

| 占位符 | 含义 | 说明 |
|--------|------|------|
| `{{user}}` | 用户名称 | - |
| `{{chat_history}}` | 对话窗口内所有上下文 | - |
| `{{last_user_message}}` | 最后一条用户消息 | - |

#### 5.4 宏系统

**A. `{{setvar}}` - 设定变量**
- 格式：`{{setvar::变量名::变量值}}`
- 示例：`{{setvar::mood::happy}}`

**B. `{{getvar}}` - 获取变量**
- 格式：`{{getvar::变量名}}`
- 示例：`{{getvar::mood}}`

**C. `{{random}}` - 随机抽取**
- 格式：`{{random::随机值1::随机值2::...}}`
- 示例：`{{random::开心::难过::平静}}`

#### 5.5 提示词组成

提示词由以下几部分组成：

1. **预设**（预设可以调节全局所有提示词的位置）
2. **用户设定**
3. **角色设定**
4. **对话窗口**
5. **用户消息**（不包括注入的部分，仅仅是对话窗口内用户发送的所有消息）

#### 5.6 处理流程

```
原始提示词
  ↓
变量替换（{{time}}, {{location}}, {{device_info}}）
  ↓
占位符替换（{{user}}, {{chat_history}}, {{last_user_message}}）
  ↓
宏展开（{{setvar}}, {{getvar}}, {{random}}）
  ↓
Role适配（根据API类型自动转换）
  ↓
排序整合（按照组成结构排序）
  ↓
注入处理（处理注入的提示词）
  ↓
最终发送给LLM
```

---

### 6. 流式计时器和思维链可折叠

#### 6.1 流式计时器
- 显示流式响应的耗时

#### 6.2 思维链可折叠
- **默认**: `<think>` 标签内容为模型思维链
- **功能**: 用户可设置是否折叠显示
- **可配置**: 给用户设置权限（自定义思维链标签）

---

### 7. Token计数器

#### 7.1 需求

- **三种接入端口对应三种计数器**
- **用项目本地来实现计数**（不走LLM端口）

#### 7.2 计数器类型

| API类型 | 计数方式 |
|---------|---------|
| OpenAI | tiktoken 或本地估算 |
| Gemini | 本地估算（中文1.5字符≈1token） |
| Anthropic | 本地估算 |

---

### 8. Dev Mode（开发者模式）

#### 8.1 目标用户

- 开发者
- 高端用户

#### 8.2 功能需求

- ✅ 查看项目的debug消息
- ✅ 查看请求体
- ✅ **开启后，页面的一半就都为log页面了**

#### 8.3 UI布局

```
┌──────────────┬──────────────┐
│              │              │
│   聊天界面   │   Log面板    │
│              │              │
│   (50%)      │   (50%)      │
│              │              │
└──────────────┴──────────────┘
```

---

## 🏗️ 核心要点与设计理念

> 本项目最重要的组成分为以下几部分：
> 1. **特殊的提示词处理机制**
> 2. **函数调用**
> 3. **MCP**
> 4. **JavaScript**
> 5. **正则表达式**

**总体定位**:
> 提示词工程 + 以函数调用、MCP为主的AI Agent，专门用于**情感陪护、角色扮演**的LLM对话客户端

---

### 1. 特殊的提示词处理机制（最核心）

这是**项目最核心、最重要的机制**。

#### 1.1 核心概念

**A. 楼层（Layer）**

- **定义**: 对对话中第n条消息的位置定位
- **原因**: 因为有"开场白"的存在
- **规则**:
  - 第一条消息（开场白）= 第0层楼
  - 第二条消息 = 第1层楼
  - 第n条消息 = 第(n-1)层楼
- **公式**: `楼层编号 = 消息序号 - 1`

**B. 深度（Depth）**

- **定义**: 对用户消息的位置定位
- **用途**: 为提示词注入而设计
- **规则**:
  - 用户在对话窗口发送的那条消息 = 深度1
  - 上一条用户消息 = 深度2
  - 上上条用户消息 = 深度3
  - 以此类推

**深度0的特殊用途**:
- 如果用户要写一个**要LLM强遵守的提示词**
- 可以使用注入功能
- 并且开启注入，深度为0

**C. 注入（Injection）**

- **定义**: 开启注入后，提示词将不会在原来的提示词序列之中，而是被后处理到要注入的位置
- **用途**: 实现强制遵守的提示词
- **机制**: 绕过正常的提示词排序，直接插入到指定深度

#### 1.2 预设（Preset）

**概念来源**: SillyTavern，但完全不同

**预设设置窗口结构**:

**A. 参数设置**
- 包括：温度、top_p等现在LLM支持的所有参数
- 用户可以通过**打勾的形式**，决定都发送给LLM什么参数
- 可以通过数值调节的，采用：
  - 数值编辑窗口
  - 滑动条
  - 两者结合的形式调节

**B. 上下文限制调节功能**
- ⚠️ **不走LLM端口**
- ⚠️ **走项目的内部计数器**
- 用户选择不同的接入端口，计数器也要不同

**C. 提示词编辑区（重头戏）**
- 用户要可以**自由增减条目**
- 在条目里编辑提示词
- 使用统一的提示词编辑器组件

---

### 2. 函数调用（Function Calling）

- 利用模型的函数调用能力
- 实现一些功能，比如：
  - 计算器
  - 天气查询
  - 搜索
  - 等等

---

### 3. MCP（Model Context Protocol）

#### 3.1 参考设计

- 参考各类编程软件的样式
- 例：VS Code的扩展管理

#### 3.2 功能需求

- **项目内部要可以自由配置JSON**
- **有个专门配置MCP的页面**
- 类似扩展市场的体验

---

### 4. JavaScript（重点功能）

#### 4.1 设计理念

透过JavaScript来实现一些**模型实现不了的东西**

#### 4.2 应用场景

**示例**: 
- 用户输入什么东西
- 透过JavaScript来发送给模型特定的提示词
- 实现动态提示词生成

#### 4.3 可能的实现

```javascript
// 伪代码示例
onUserInput((input) => {
  if (input.includes('关键词')) {
    injectPrompt('特定的提示词内容');
  }
});
```

---

### 5. 正则表达式

#### 5.1 功能

**后处理模型的输出或输入**

#### 5.2 特性

- **可选功能**: 用户可以开启/关闭
- **可作用于**:
  - 提示词部分
  - 模型输出
  - 用户输入

#### 5.3 作用模式

用户可选：

**A. 实际修改模式**
- 真正修改内容
- 改变发送给模型的内容

**B. 视觉效果修改模式**
- 仅在UI层面修改显示
- 不改变实际内容

---

## 📐 数据模型设计（推荐）

### 核心概念

```typescript
// 楼层（Layer）
export interface MessageLayer {
  layer: number;        // 楼层编号（从0开始）
  messageId: string;
  role: 'user' | 'assistant' | 'system';
}

// 深度（Depth）
export interface PromptDepth {
  depth: number;        // 深度编号（0为最高优先级）
  targetLayer: number;  // 目标楼层
}

// 注入（Injection）
export interface PromptInjection {
  enabled: boolean;
  depth: number;        // 注入深度
  position: 'before' | 'after' | 'replace';
}

// 提示词项目
export interface PromptItem {
  id: string;
  order: number;        // 排序
  content: string;      // 提示词内容
  enabled: boolean;     // 是否启用
  role: 'system' | 'user' | 'assistant';
  
  // 注入配置
  injection?: PromptInjection;
}

// 预设
export interface Preset {
  id: string;
  name: string;
  
  // 模型参数
  parameters: ModelParameters;
  enabledParameters: Set<string>;
  
  // 上下文限制（本地计数器）
  contextLimit: {
    maxTokens: number;
    strategy: 'sliding_window' | 'summary';
  };
  
  // 提示词序列
  prompts: PromptItem[];
  
  // 全局位置
  globalPosition: 'before_all' | 'after_character' | 'custom';
}

// 角色（新版）
export interface Character {
  id: string;
  name: string;         // 仅UI显示
  description: string;  // 仅用户备注
  avatar?: string;
  
  // 开场白（第0层楼）
  openingMessage: string;
  
  // 提示词配置
  prompts: PromptItem[];
  
  createdAt: string;
  updatedAt: string;
}

// 渲染配置
export interface RenderingConfig {
  markdown: boolean;
  html: boolean;
  codeHighlight: {
    enabled: boolean;
    theme: string;
  };
  specialFields: {
    quoted: { enabled: boolean; style: React.CSSProperties };
    parenthesized: { enabled: boolean; style: React.CSSProperties };
  };
  customCSS: string;
}

// 开发者模式日志
export interface DevLog {
  id: string;
  timestamp: string;
  type: 'debug' | 'request' | 'response' | 'error';
  message: string;
  data?: any;
}
```

---

## 🎨 UI/UX 设计要求

### 整体风格

- ❌ **不要**：网页端LLM的交互体验
- ✅ **要**：正经客户端的感觉
- 💡 **参考反例**: SillyTavern（过于重型和陈旧）

### 设计目标

- 轻量级
- 现代化
- 直观
- 专业

---

## 🔐 架构原则（强调）

> **所有功能均用独立单元模块实现**

### 模块化要求

- ✅ 高度解耦
- ✅ 独立可测试
- ✅ 可替换
- ✅ 单一职责

### 为什么强调这一点

> "不可以都耦合在一起，那样维护和debug太灾难了"

### 示例模块划分

```
modules/
├── prompt-processor/     # 提示词后处理
├── role-adapter/         # Role适配器
├── variable-resolver/    # 变量解析器
├── macro-processor/      # 宏处理器
├── injection-handler/    # 注入处理器
├── token-counter/        # Token计数器
├── rendering-engine/     # 渲染引擎
├── function-calling/     # 函数调用
├── mcp-client/          # MCP客户端
└── javascript-runtime/   # JavaScript运行时
```

---

## 📝 实施优先级（建议）

### Phase 0: 核心提示词系统（最高优先级）

1. **楼层/深度/注入机制**
2. **统一提示词编辑器**
3. **提示词后处理系统**
   - 变量/占位符/宏
   - Role适配
   - 排序整合
4. **角色编辑页面改造**
5. **预设系统**

### Phase 1: 渲染与UI优化

1. **渲染系统**
   - Markdown/HTML支持
   - 特殊字段渲染
   - CSS自定义工具
2. **UI/UX改进**
   - 客户端风格
   - 流式计时器
   - 思维链折叠

### Phase 2: 高级功能

1. **Token计数器**
2. **Dev Mode**
3. **函数调用框架**
4. **MCP集成**
5. **JavaScript运行时**
6. **正则表达式处理**

---

**文档版本**: v1.0  
**最后更新**: 2025-11-23